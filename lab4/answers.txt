# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Cameron Solomon
Student ID: 603 809 897
Email: cameronjsolomon@ucla.edu

# Partner 2 (if you're working in a team)
Name: Ervin Sukardi
Student ID: 203 808 277
Email: emsukardi@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
Our method for running peer downloads and uploads in parallel was to use fork()
to create new threads that would complete downloads and uploads for us.
Our version of osppeer has a single parent process create a new child process
for every download and upload instance. The child processes perform the download
or upload, and then exit, while the parent continues to spawn more download
and upload instances until the user interrupts it.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)
Download attacks:  Get the list of peers serving cat1.jpg and attempt to attack 
each of them.
First try to attack them by buffer overflow.  Send them a GET request with a 
filename nearly 4 times filename buffer size, not null ended.  When the peer 
attempts to strcpy the name they will cause segfaults if they have not 
properly checked the filename is too long.  If we crafted it even better, it
might be possible to attack by putting some attack code into the overflow.
Attempt to grab the osppeer.c code itself by attempting a GET ../osppeer.c
this is merely a violation of security, we can now see how their peer runs.  The
info is great for planning some future attacks on them and exploiting bugs in
their code.
Next attempt to clog them up by starting a lot of socket connections and
requesting a valid file.  The peer may fill up their buffer or spend a lot of
effort servicing these requests while we don't even look at the data they give
us.
Upload attack: When a peer connects, give them an unlimited data stream
simply continue sending trash data to the peer without stopping.  The peer
may have no way of knowing whether this is the valid file, and if it doesn't
stop us from sending data, it's harddisk could fill up with useless data.


# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.
